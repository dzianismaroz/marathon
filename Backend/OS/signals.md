# Сигналы в Linux

Сигналы в Linux — это механизм межпроцессного взаимодействия (IPC), позволяющий процессам и ядру отправлять асинхронные уведомления друг другу. 

---

### Основные характеристики сигналов

1. **Асинхронность**  
   Сигналы могут быть отправлены процессу в любой момент времени. Процесс обрабатывает сигнал при следующем изменении состояния.

2. **Универсальность**  
   Сигналы могут посылаться:
   - От одного процесса другому.
   - От ядра процессу.
   - Самим процессом себе.

3. **Идентификация сигналов**  
   Каждый сигнал имеет уникальный идентификатор (целое число). Примеры:
   - `SIGTERM` (15): Завершение процесса.
   - `SIGKILL` (9): Принудительное завершение процесса (не может быть перехвачен или игнорирован).
   - `SIGSTOP` (19): Остановка выполнения процесса.
   - `SIGCONT` (18): Продолжение выполнения процесса.

4. **Поведение по умолчанию**  
   Для каждого сигнала определено стандартное поведение:
   - Завершение процесса (`SIGTERM`, `SIGINT`).
   - Игнорирование (`SIGCHLD`).
   - Остановка или продолжение выполнения (`SIGSTOP`, `SIGCONT`).

---

### Работа с сигналами

#### Отправка сигналов

1. **Команда `kill`**
   Отправляет сигнал процессу по его PID:
   ```bash
   kill -SIGTERM <PID>
   kill -9 <PID> # SIGKILL
2. **Системный вызов `kill`** Используется в программах:
```c
#include <signal.h>
kill(pid, SIGTERM);
```
3. ***Утилита `pkill`** Позволяет отправить сигнал процессу по его имени:
```bash
pkill -HUP mydaemon
```
### Обработка сигналов

1. **Игнорирование сигнала**  Процесс может настроить игнорирование сигнала (кроме `SIGKILL` и `SIGSTOP`):

```c 
 signal(SIGTERM, SIG_IGN);
 ```
 2. **Установка обработчика** Можно задать пользовательскую функцию для обработки сигнала:
 ```c
 #include <signal.h>
#include <stdio.h>

void handle_sigint(int sig) {
    printf("Caught signal %d\n", sig);
}

int main() {
    signal(SIGINT, handle_sigint);
    while (1); // Бесконечный цикл
    return 0;
}
 ```
 3. **Использование `sigaction`** Более современный способ задания обработчиков:
 ```c
 #include <signal.h>
#include <stdio.h>

void handle_sigusr1(int sig) {
    printf("Handled SIGUSR1\n");
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handle_sigusr1;
    sa.sa_flags = 0;
    sigaction(SIGUSR1, &sa, NULL);

    while (1);
    return 0;
}
 ```
 ### Блокировка сигналов
 Для временной блокировки сигналов используются маски:
 ```c
 #include <signal.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    sigset_t block_set;
    sigemptyset(&block_set);
    sigaddset(&block_set, SIGINT);

    // Блокируем SIGINT
    sigprocmask(SIG_BLOCK, &block_set, NULL);
    printf("SIGINT blocked. Press Ctrl+C now.\n");
    sleep(5);

    // Разблокируем SIGINT
    sigprocmask(SIG_UNBLOCK, &block_set, NULL);
    printf("SIGINT unblocked. Try Ctrl+C again.\n");
    sleep(5);

    return 0;
}
```
### Применение сигналов
1. **Рестарт демонов через `SIGHUP`** Демоны используют SIGHUP для перезагрузки конфигурации:

```bash
kill -HUP <PID>
```
2. **Управление группами процессов** Сигналы могут отправляться всем процессам в группе, используя `kill` или `pkill`.

3. **Дебаггинг через `SIGSTOP` и `SIGCONT`** Сигналы позволяют приостанавливать и продолжать выполнение процессов.

### Особенности и ограничения

1. `SIGKILL` и `SIGSTOP` **нельзя перехватить** Эти сигналы управляются ядром и не могут быть обработаны или игнорированы.

2. **Ограниченное количество сигналов** Количество сигналов фиксировано (определено в POSIX). В Linux есть дополнительные реальные временные сигналы (`SIGRTMIN` - `SIGRTMAX`).

3. **Многопоточность* В многопоточных приложениях сигналы могут направляться отдельным потокам через `pthread_kill` и управляться с помощью `pthread_sigmask`.