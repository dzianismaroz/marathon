
### 1. **Сортировка пузырьком (Bubble Sort)**

**Алгоритм**:
Это один из самых простых и интуитивно понятных алгоритмов сортировки. Он работает путём многократного прохода по списку, сравнивая соседние элементы и меняя их местами, если они идут в неправильном порядке.

**Пример на Go**:

```go
package main

import "fmt"

func bubbleSort(arr []int) {
	n := len(arr)
	for i := 0; i < n-1; i++ {
		for j := 0; j < n-i-1; j++ {
			if arr[j] > arr[j+1] {
				arr[j], arr[j+1] = arr[j+1], arr[j]
			}
		}
	}
}

func main() {
	arr := []int{64, 34, 25, 12, 22, 11, 90}
	bubbleSort(arr)
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n²) — в худшем и среднем случае (по количеству сравнений и перестановок).
- **Стабильность**: Алгоритм стабильный, то есть сохраняет порядок равных элементов.
- **Производительность**: Очень медленный для больших массивов, из-за большого числа сравнений и перестановок.

---

### 2. **Сортировка выбором (Selection Sort)**

**Алгоритм**:
Этот алгоритм сортирует массив, поочередно выбирая минимальный (или максимальный) элемент и меняя его местами с текущим элементом.

**Пример на Go**:

```go
package main

import "fmt"

func selectionSort(arr []int) {
	n := len(arr)
	for i := 0; i < n-1; i++ {
		minIdx := i
		for j := i + 1; j < n; j++ {
			if arr[j] < arr[minIdx] {
				minIdx = j
			}
		}
		arr[i], arr[minIdx] = arr[minIdx], arr[i]
	}
}

func main() {
	arr := []int{64, 25, 12, 22, 11}
	selectionSort(arr)
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n²) — независимо от того, отсортирован ли массив или нет.
- **Стабильность**: Этот алгоритм нестабилен (не гарантирует сохранение порядка одинаковых элементов).
- **Производительность**: Подходит для маленьких массивов, но работает медленно на больших данных.

---

### 3. **Сортировка вставками (Insertion Sort)**

**Алгоритм**:
Сортировка вставками работает путём перебора каждого элемента и вставки его в уже отсортированную часть массива.

**Пример на Go**:

```go
package main

import "fmt"

func insertionSort(arr []int) {
	for i := 1; i < len(arr); i++ {
		key := arr[i]
		j := i - 1
		// Сдвигаем элементы, которые больше ключа, на одну позицию вправо
		for j >= 0 && arr[j] > key {
			arr[j+1] = arr[j]
			j--
		}
		arr[j+1] = key
	}
}

func main() {
	arr := []int{12, 11, 13, 5, 6}
	insertionSort(arr)
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n²) — в худшем случае (если элементы отсортированы в обратном порядке).
- **Стабильность**: Алгоритм стабилен.
- **Производительность**: Быстрая сортировка для маленьких или частично отсортированных массивов.

---

### 4. **Сортировка слиянием (Merge Sort)**

**Алгоритм**:
Сортировка слиянием использует принцип "разделяй и властвуй", рекурсивно разделяя массив пополам и сортируя каждую половину, а затем сливая отсортированные части.

**Пример на Go**:

```go
package main

import "fmt"

func mergeSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr
	}
	mid := len(arr) / 2
	left := mergeSort(arr[:mid])
	right := mergeSort(arr[mid:])
	return merge(left, right)
}

func merge(left, right []int) []int {
	result := []int{}
	i, j := 0, 0
	for i < len(left) && j < len(right) {
		if left[i] < right[j] {
			result = append(result, left[i])
			i++
		} else {
			result = append(result, right[j])
			j++
		}
	}
	result = append(result, left[i:]...)
	result = append(result, right[j:]...)
	return result
}

func main() {
	arr := []int{38, 27, 43, 3, 9, 82, 10}
	arr = mergeSort(arr)
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n log n) — в худшем, среднем и лучшем случае.
- **Стабильность**: Алгоритм стабилен.
- **Производительность**: Хорошо работает на больших данных, но требует дополнительной памяти для слияния массивов.

---

### 5. **Сортировка быстрая (Quick Sort)**

**Алгоритм**:
Сортировка быстрая также использует принцип "разделяй и властвуй". Она выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и элементы больше опорного. Затем рекурсивно сортирует каждую из частей.

**Пример на Go**:

```go
package main

import "fmt"

func quickSort(arr []int) {
	if len(arr) <= 1 {
		return
	}
	pivot := arr[0]
	left := []int{}
	right := []int{}
	for _, v := range arr[1:] {
		if v < pivot {
			left = append(left, v)
		} else {
			right = append(right, v)
		}
	}
	quickSort(left)
	quickSort(right)
	copy(arr, append(append(left, pivot), right...))
}

func main() {
	arr := []int{10, 80, 30, 90, 40, 50, 70}
	quickSort(arr)
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n log n) — в среднем случае, O(n²) — в худшем (если опорный элемент всегда выбран неудачно).
- **Стабильность**: Этот алгоритм нестабилен.
- **Производительность**: Очень быстрый на больших данных в среднем случае. Однако выбор плохого опорного элемента может привести к худшему времени работы.

---

### 6. **Сортировка кучей (Heap Sort)**

**Алгоритм**:
Сортировка кучей строит максимальную (или минимальную) кучу и поочередно извлекает максимальный элемент из кучи, помещая его в конец массива.

**Пример на Go**:

```go
package main

import "fmt"

func heapify(arr []int, n, i int) {
	largest := i
	left := 2*i + 1
	right := 2*i + 2

	if left < n && arr[left] > arr[largest] {
		largest = left
	}
	if right < n && arr[right] > arr[largest] {
		largest = right
	}
	if largest != i {
		arr[i], arr[largest] = arr[largest], arr[i]
		heapify(arr, n, largest)
	}
}

func heapSort(arr []int) {
	n := len(arr)
	for i := n / 2 - 1; i >= 0; i-- {
		heapify(arr, n, i)
	}
	for i := n - 1; i > 0; i-- {
		arr[i], arr[0] = arr[0], arr[i]
		heapify(arr, i, 0)
	}
}

func main() {
	arr := []int{12, 11, 13, 5, 6, 7}
	heapSort(arr)
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n log n) в худшем, среднем и лучшем случае.
- **Стабильность**: Алгоритм нестабилен.
- **Производительность**: Хорошо работает на больших данных, но требует дополнительного времени для построения кучи.

---

### 7. **Тимсорт (Tim Sort)**

**Алгоритм**:
Тимсорт — это гибридный алгоритм сортировки, который использует сортировку вставками для небольших подмассив

ов и сортировку слиянием для более крупных.

**Пример на Go**:
В Go нет стандартной реализации TimSort, но его можно использовать через стандартную библиотеку:

```go
package main

import (
	"fmt"
	"sort"
)

func main() {
	arr := []int{38, 27, 43, 3, 9, 82, 10}
	sort.Ints(arr) // TimSort используется внутри sort.Ints
	fmt.Println("Отсортированный массив:", arr)
}
```

**Нюансы**:
- **Время работы**: O(n log n) — в худшем, среднем и лучшем случае.
- **Стабильность**: Алгоритм стабилен.
- **Производительность**: Очень быстрый и эффективный для реальных данных, использует комбинацию сортировки вставками и слиянием.

---

### Заключение:
Каждый алгоритм имеет свои сильные и слабые стороны. Выбор алгоритма сортировки зависит от особенностей данных, которые вы сортируете. Например, для маленьких или частично отсортированных массивов хороша сортировка вставками, а для больших данных лучше подходят алгоритмы с более низким временем работы, такие как быстрая сортировка или сортировка слиянием.